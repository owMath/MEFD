/**
Aluno: Matheus Paul Lopuch
TDE-1, M√ÅQUINAS DE ESTADO FINITO E GRAM√ÅTICAS

a) ùêø0 = {ùë• | ùë• ‚àà {0,1}‚àó ùëí ùëêùëéùëëùëé 0 ùëíùëö ùë• √© ùë†ùëíùëîùë¢ùëñùëëùëú ùëùùëúùëü ùëùùëíùëôùëú ùëöùëíùëõùëúùë† ùë¢ùëö 1};
b) ùêø1 = {ùë• | ùë• ‚àà {0,1}‚àó ùëí ùë• ùë°ùëíùëüùëöùëñùëõùëé ùëêùëúùëö 00};
c) ùêø2 = {ùë• |ùë• ‚àà {0,1}‚àó ùëí ùë• ùëêùëúùëõùë°√©ùëö ùëíùë•ùëéùë°ùëéùëöùëíùëõùë°ùëí 3 ùëßùëíùëüùëúùë†};
d) ùêø3 = {ùë• |ùë• ‚àà {0,1}‚àó ùëí ùë• ùëñùëõùëñùëêùëñùëé ùëêùëúùëö 1};
e) ùêø4 = {ùë• |ùë• ‚àà {0,1}‚àó ùëí ùë• ùëõ√£ùëú ùëêùëúùëöùëí√ßùëé ùëêùëúùëö 1}; 

Implemente, utilizando a linguagem C um programa capaz de implementar cada uma
destas m√°quinas na plataforma Ardu√≠no. Neste caso, as strings de entrada dever√£o
ser configuradas manualmente e a identifica√ß√£o, ou n√£o, dever√° ser feita por um led. 
 */

// Pino para o LED
#define LED_PIN 13  

// Defini√ß√£o dos estados para cada m√°quina
// MEFD-0
#define L0_S0 0  // Estado inicial e de aceita√ß√£o
#define L0_S1 1  // Estado n√£o-aceitante

// MEFD-1
#define L1_S0 0  // Estado inicial
#define L1_S1 1  // Estado intermedi√°rio
#define L1_S2 2  // Estado de aceita√ß√£o

// MEFD-2
#define L2_S0 0  // Estado inicial
#define L2_S1 1  // Estado ap√≥s 1 zero
#define L2_S2 2  // Estado ap√≥s 2 zeros
#define L2_S3 3  // Estado ap√≥s 3 zeros (aceita√ß√£o)
#define L2_FINAL 4  // Estado morto

// MEFD-3
#define L3_S0 0  // Estado inicial
#define L3_S1 1  // Estado de aceita√ß√£o
#define L3_FINAL 2  // Estado morto

// MEFD-4
#define L4_S0 0  // Estado inicial
#define L4_S1 1  // Estado de aceita√ß√£o
#define L4_FINAL 2  // Estado morto

// Vari√°veis globais
int currentMachine = 0;  // M√°quina selecionada (0-4)
int currentState = 0;    // Estado atual da m√°quina selecionada
bool accepted = false;   // Indica se a string atual √© aceita
char serialBuffer[64];   // Buffer para entrada via Serial
int bufferIndex = 0;     // √çndice atual no buffer

// Nomes das m√°quinas para exibi√ß√£o no Serial
const char* machineNames[] = {
  "L0: cada 0 √© seguido por pelo menos um 1",
  "L1: termina com 00",
  "L2: cont√©m exatamente 3 zeros",
  "L3: inicia com 1",
  "L4: n√£o come√ßa com 1"
};

// Strings de teste para cada m√°quina (exemplos de strings aceitas)
const char* testStrings[] = {
  "010111",   // L0: cada 0 √© seguido por pelo menos um 1
  "100",      // L1: termina com 00
  "10100",    // L2: cont√©m exatamente 3 zeros
  "101",      // L3: inicia com 1
  "011"       // L4: n√£o come√ßa com 1
};

// Strings de teste negativas para cada m√°quina (exemplos de strings rejeitadas)
const char* negativeTestStrings[] = {
  "10110",    // L0: cont√©m um 0 n√£o seguido por 1
  "10",       // L1: n√£o termina com 00
  "10000",    // L2: cont√©m mais de 3 zeros
  "011",      // L3: n√£o inicia com 1
  "101"       // L4: come√ßa com 1
};

void setup() {
  // Configura√ß√£o do pino do LED
  pinMode(LED_PIN, OUTPUT);
  
  // Inicializa a comunica√ß√£o serial
  Serial.begin(9600);
  
  // Mostra o menu inicial
  showMainMenu();
}

void loop() {
  // Verifica se h√° dados dispon√≠veis na Serial
  while (Serial.available() > 0) {
    char inChar = Serial.read();
    
    // Se receber Enter (carriage return ou newline), processa o comando
    if (inChar == '\r' || inChar == '\n') {
      if (bufferIndex > 0) {
        serialBuffer[bufferIndex] = '\0';  // Finaliza a string
        processCommand(serialBuffer);
        bufferIndex = 0;  // Reinicia o buffer
      }
    } else if (bufferIndex < sizeof(serialBuffer) - 1) {
      serialBuffer[bufferIndex++] = inChar;  // Adiciona o caractere ao buffer
    }
  }
}

// Exibe o menu principal
void showMainMenu() {
  Serial.println("\n==== M√ÅQUINAS DE ESTADO FINITO (MEFD) ====");
  Serial.println("Selecione uma op√ß√£o:");
  Serial.println("1-5: Selecionar m√°quina (1 = L0, 2 = L1, etc.)");
  Serial.println("t: Testar a m√°quina atual com string de exemplo que DEVE ser aceita");
  Serial.println("n: Testar a m√°quina atual com string de exemplo que N√ÉO deve ser aceita");
  Serial.println("s: Inserir sua pr√≥pria string para testar");
  Serial.println("m: Mostrar este menu");
  Serial.println("i: Informa√ß√µes sobre a m√°quina atual");
  Serial.println("=====================================");
  
  // Mostra a m√°quina atual
  Serial.print("M√°quina atual: ");
  Serial.println(machineNames[currentMachine]);
}

// Processa um comando recebido via Serial
void processCommand(const char* cmd) {
  // Comando de um √∫nico caractere
  if (strlen(cmd) == 1) {
    char command = cmd[0];
    
    switch (command) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
        // Seleciona a m√°quina (1-5 correspondem a L0-L4)
        currentMachine = command - '1';
        Serial.print("M√°quina selecionada: ");
        Serial.println(machineNames[currentMachine]);
        resetMachine();
        break;
        
      case 't':
        // Testa com string positiva
        Serial.print("Testando string que deve ser ACEITA: ");
        Serial.println(testStrings[currentMachine]);
        testString(testStrings[currentMachine]);
        break;
        
      case 'n':
        // Testa com string negativa
        Serial.print("Testando string que deve ser REJEITADA: ");
        Serial.println(negativeTestStrings[currentMachine]);
        testString(negativeTestStrings[currentMachine]);
        break;
        
      case 'm':
        // Mostra o menu
        showMainMenu();
        break;
        
      case 'i':
        // Mostra informa√ß√µes da m√°quina atual
        showMachineInfo();
        break;
        
      case 's':
        // Solicita uma string para testar
        Serial.println("Digite uma string de 0s e 1s para testar (seguida de Enter):");
        break;
        
      default:
        // Comando n√£o reconhecido
        Serial.println("Comando n√£o reconhecido. Digite 'm' para ver o menu.");
        break;
    }
  } else if (cmd[0] == 's' && cmd[1] == ' ') {
    // Comando para testar uma string espec√≠fica
    testString(cmd + 2);  // Pula o "s " inicial
  } else {
    // Verifica se a string cont√©m apenas 0s e 1s
    bool validBinary = true;
    for (int i = 0; cmd[i] != '\0'; i++) {
      if (cmd[i] != '0' && cmd[i] != '1') {
        validBinary = false;
        break;
      }
    }
    
    if (validBinary) {
      // Testa a string bin√°ria
      Serial.print("Testando string personalizada: ");
      Serial.println(cmd);
      testString(cmd);
    } else {
      Serial.println("Comando n√£o reconhecido. Digite 'm' para ver o menu.");
    }
  }
}

// Mostra informa√ß√µes detalhadas sobre a m√°quina atual
void showMachineInfo() {
  Serial.println("\n--- Informa√ß√µes da M√°quina ---");
  Serial.print("M√°quina: ");
  Serial.println(machineNames[currentMachine]);
  
  Serial.println("Descri√ß√£o da linguagem reconhecida:");
  switch (currentMachine) {
    case 0:
      Serial.println("L0 = {x | x ‚àà {0,1}* e cada 0 em x √© seguido por pelo menos um 1}");
      Serial.println("Exemplos aceitos: 010111, 1111, 01110111011");
      break;
    case 1:
      Serial.println("L1 = {x | x ‚àà {0,1}* e x termina com 00}");
      Serial.println("Exemplos aceitos: 00, 100, 11100");
      break;
    case 2:
      Serial.println("L2 = {x | x ‚àà {0,1}* e x cont√©m exatamente 3 zeros}");
      Serial.println("Exemplos aceitos: 000, 010100, 111000111");
      break;
    case 3:
      Serial.println("L3 = {x | x ‚àà {0,1}* e x inicia com 1}");
      Serial.println("Exemplos aceitos: 1, 10, 1110");
      break;
    case 4:
      Serial.println("L4 = {x | x ‚àà {0,1}* e x n√£o come√ßa com 1}");
      Serial.println("Exemplos aceitos: Œµ (string vazia), 0, 01110");
      break;
  }
  
  Serial.println("\nUse os comandos:");
  Serial.println("'t' para testar com um exemplo positivo");
  Serial.println("'n' para testar com um exemplo negativo");
  Serial.println("'s' seguido da sua string para testar uma entrada personalizada");
}

// Testa uma string espec√≠fica na m√°quina atual
void testString(const char* str) {
  resetMachine();
  
  Serial.print("Processando: ");
  
  // Processa cada s√≠mbolo da string
  for (int i = 0; str[i] != '\0'; i++) {
    int input = str[i] - '0';  // Converte de char para int (0 ou 1)
    Serial.print(input);
    processInput(input);
  }
  
  // Exibe o resultado
  Serial.print(" -> ");
  if (accepted) {
    Serial.println("ACEITO ‚úì");
  } else {
    Serial.println("REJEITADO ‚úó");
  }
  
  // Mant√©m o LED indicando o estado final
  updateLED();
}

// Reinicia a m√°quina selecionada
void resetMachine() {
  switch (currentMachine) {
    case 0:  // L0
      currentState = L0_S0;
      accepted = true;  // Estado inicial √© de aceita√ß√£o
      break;
    case 1:  // L1
      currentState = L1_S0;
      accepted = false;  // Estado inicial n√£o √© de aceita√ß√£o
      break;
    case 2:  // L2
      currentState = L2_S0;
      accepted = false;  // Estado inicial n√£o √© de aceita√ß√£o
      break;
    case 3:  // L3
      currentState = L3_S0;
      accepted = false;  // Estado inicial n√£o √© de aceita√ß√£o
      break;
    case 4:  // L4
      currentState = L4_S0;
      accepted = true;  // Estado inicial √© de aceita√ß√£o
      break;
  }
  
  // Atualiza o LED
  updateLED();
}

// Processa uma entrada (0 ou 1) na m√°quina atual
void processInput(int input) {
  switch (currentMachine) {
    case 0:  // L0: cada 0 √© seguido por pelo menos um 1
      processL0(input);
      break;
    case 1:  // L1: termina com 00
      processL1(input);
      break;
    case 2:  // L2: cont√©m exatamente 3 zeros
      processL2(input);
      break;
    case 3:  // L3: inicia com 1
      processL3(input);
      break;
    case 4:  // L4: n√£o come√ßa com 1
      processL4(input);
      break;
  }
  
  // Atualiza o LED
  updateLED();
}

// Implementa√ß√£o da MEFD-0
void processL0(int input) {
  switch (currentState) {
    case L0_S0:  // Estado inicial e de aceita√ß√£o
      if (input == 0) {
        currentState = L0_S1;
        accepted = false;
      }
      // Se input == 1, permanece em S0
      break;
    case L0_S1:  // Estado n√£o-aceitante
      if (input == 1) {
        currentState = L0_S0;
        accepted = true;
      }
      // Se input == 0, permanece em S1
      break;
  }
}

// Implementa√ß√£o da MEFD-1
void processL1(int input) {
  switch (currentState) {
    case L1_S0:  // Estado inicial
      if (input == 0) {
        currentState = L1_S1;
      }
      // Se input == 1, permanece em S0
      accepted = false;
      break;
    case L1_S1:  // Estado intermedi√°rio
      if (input == 0) {
        currentState = L1_S2;
        accepted = true;
      } else {  // input == 1
        currentState = L1_S0;
        accepted = false;
      }
      break;
    case L1_S2:  // Estado de aceita√ß√£o
      if (input == 1) {
        currentState = L1_S0;
        accepted = false;
      }
      // Se input == 0, permanece em S2 e accepted = true
      break;
  }
}

// Implementa√ß√£o da MEFD-2
void processL2(int input) {
  switch (currentState) {
    case L2_S0:  // Estado inicial
      if (input == 0) {
        currentState = L2_S1;
      }
      // Se input == 1, permanece em S0
      accepted = false;
      break;
    case L2_S1:  // Estado ap√≥s 1 zero
      if (input == 0) {
        currentState = L2_S2;
      }
      // Se input == 1, permanece em S1
      accepted = false;
      break;
    case L2_S2:  // Estado ap√≥s 2 zeros
      if (input == 0) {
        currentState = L2_S3;
        accepted = true;
      }
      // Se input == 1, permanece em S2
      break;
    case L2_S3:  // Estado ap√≥s 3 zeros (aceita√ß√£o)
      if (input == 0) {
        currentState = L2_FINAL;
        accepted = false;
      }
      // Se input == 1, permanece em S3 e accepted = true
      break;
    case L2_FINAL:  // Estado morto
      // Permanece no estado morto independente da entrada
      accepted = false;
      break;
  }
}

// Implementa√ß√£o da MEFD-3
void processL3(int input) {
  switch (currentState) {
    case L3_S0:  // Estado inicial
      if (input == 0) {
        currentState = L3_FINAL;
        accepted = false;
      } else {  // input == 1
        currentState = L3_S1;
        accepted = true;
      }
      break;
    case L3_S1:  // Estado de aceita√ß√£o
      // Permanece no estado de aceita√ß√£o independente da entrada
      // accepted = true (j√° est√° definido)
      break;
    case L3_FINAL:  // Estado morto
      // Permanece no estado morto independente da entrada
      // accepted = false (j√° est√° definido)
      break;
  }
}

// Implementa√ß√£o da MEFD-4
void processL4(int input) {
  switch (currentState) {
    case L4_S0:  // Estado inicial
      if (input == 0) {
        currentState = L4_S1;
        accepted = true;
      } else {  // input == 1
        currentState = L4_FINAL;
        accepted = false;
      }
      break;
    case L4_S1:  // Estado de aceita√ß√£o
      // Permanece no estado de aceita√ß√£o independente da entrada
      // accepted = true (j√° est√° definido)
      break;
    case L4_FINAL:  // Estado morto
      // Permanece no estado morto independente da entrada
      // accepted = false (j√° est√° definido)
      break;
  }
}

// Atualiza o LED de acordo com o estado atual
void updateLED() {
  digitalWrite(LED_PIN, accepted ? HIGH : LOW);
}